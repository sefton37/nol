//! Rich contracts programs (20): ex165-ex184.

use super::{i64_case, Category, ProgramSpec};

pub fn programs() -> Vec<ProgramSpec> {
    vec![
        // ex165: abs_contract (simple POST: result >= 0)
        ProgramSpec {
            id: "ex165_abs_contract",
            intent: "Compute absolute value with contract ensuring non-negative result",
            assembly_template: concat!(
                "FUNC 1 17\n",
                "PARAM I64\n",
                "POST 3\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GTE\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "LT\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "REF 0\n",
                "CASE 1 2\n",
                "REF 0\n",
                "NEG\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0xffff 0xfffb\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[-5], 5),
                i64_case(&[3], 3),
                i64_case(&[0], 0),
                i64_case(&[-10], 10),
            ],
            category: Category::RichContracts,
        },
        // ex166: max_contract (POST: result >= a AND result >= b)
        ProgramSpec {
            id: "ex166_max_contract",
            intent: "Find maximum of two integers with contract ensuring result is at least both inputs",
            assembly_template: concat!(
                "FUNC 2 21\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "POST 3\n",
                "REF 0\n",
                "REF 2\n",
                "GTE\n",
                "POST 3\n",
                "REF 0\n",
                "REF 1\n",
                "GTE\n",
                "REF 1\n",
                "REF 0\n",
                "GTE\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "REF 0\n",
                "CASE 1 1\n",
                "REF 1\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CONST I64 0x0000 0x0003\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5, 3], 5),
                i64_case(&[3, 5], 5),
                i64_case(&[7, 7], 7),
                i64_case(&[-1, -5], -1),
            ],
            category: Category::RichContracts,
        },
        // ex167: min_contract (POST: result <= a AND result <= b)
        ProgramSpec {
            id: "ex167_min_contract",
            intent: "Find minimum of two integers with contract ensuring result is at most both inputs",
            assembly_template: concat!(
                "FUNC 2 21\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "POST 3\n",
                "REF 0\n",
                "REF 2\n",
                "LTE\n",
                "POST 3\n",
                "REF 0\n",
                "REF 1\n",
                "LTE\n",
                "REF 1\n",
                "REF 0\n",
                "LTE\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "REF 0\n",
                "CASE 1 1\n",
                "REF 1\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CONST I64 0x0000 0x0003\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5, 3], 3),
                i64_case(&[3, 5], 3),
                i64_case(&[7, 7], 7),
                i64_case(&[-1, -5], -5),
            ],
            category: Category::RichContracts,
        },
        // ex168: clamp_contract (PRE: lo<=hi, POST: lo<=result<=hi)
        ProgramSpec {
            id: "ex168_clamp_contract",
            intent: "Clamp x to the range [lo, hi] with pre and post contracts",
            assembly_template: concat!(
                "FUNC 3 34\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "PRE 3\n",
                "REF 1\n",
                "REF 0\n",
                "LTE\n",
                "POST 3\n",
                "REF 2\n",
                "REF 0\n",
                "LTE\n",
                "POST 3\n",
                "REF 0\n",
                "REF 1\n",
                "LTE\n",
                "REF 2\n",
                "REF 1\n",
                "LT\n",
                "MATCH 2\n",
                "CASE 0 9\n",
                "REF 2\n",
                "REF 0\n",
                "GT\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "REF 2\n",
                "CASE 1 1\n",
                "REF 0\n",
                "EXHAUST\n",
                "CASE 1 1\n",
                "REF 1\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CONST I64 0x0000 0x0000\n",
                "CONST I64 0x0000 0x000a\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5, 0, 10], 5),
                i64_case(&[-5, 0, 10], 0),
                i64_case(&[15, 0, 10], 10),
                i64_case(&[7, 0, 10], 7),
            ],
            category: Category::RichContracts,
        },
        // ex169: square_contract (POST: result >= 0)
        ProgramSpec {
            id: "ex169_square_contract",
            intent: "Compute square with contract ensuring non-negative result",
            assembly_template: concat!(
                "FUNC 1 10\n",
                "PARAM I64\n",
                "POST 3\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GTE\n",
                "REF 0\n",
                "REF 0\n",
                "MUL\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0xffff 0xfffc\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[4], 16),
                i64_case(&[-4], 16),
                i64_case(&[0], 0),
                i64_case(&[7], 49),
            ],
            category: Category::RichContracts,
        },
        // ex170: double_contract (POST: result == x + x)
        ProgramSpec {
            id: "ex170_double_contract",
            intent: "Double an integer with contract ensuring result equals twice the input",
            assembly_template: concat!(
                "FUNC 1 12\n",
                "PARAM I64\n",
                "POST 5\n",
                "REF 0\n",
                "REF 1\n",
                "REF 1\n",
                "ADD\n",
                "EQ\n",
                "REF 0\n",
                "REF 0\n",
                "ADD\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5], 10),
                i64_case(&[0], 0),
                i64_case(&[-3], -6),
                i64_case(&[7], 14),
            ],
            category: Category::RichContracts,
        },
        // ex171: increment_contract (POST: result == x+1)
        ProgramSpec {
            id: "ex171_increment_contract",
            intent: "Increment an integer with contract ensuring result is input plus one",
            assembly_template: concat!(
                "FUNC 1 12\n",
                "PARAM I64\n",
                "POST 5\n",
                "REF 0\n",
                "REF 1\n",
                "CONST I64 0x0000 0x0001\n",
                "ADD\n",
                "EQ\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0001\n",
                "ADD\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5], 6),
                i64_case(&[0], 1),
                i64_case(&[-1], 0),
                i64_case(&[99], 100),
            ],
            category: Category::RichContracts,
        },
        // ex172: identity_contract (POST: result == x)
        ProgramSpec {
            id: "ex172_identity_contract",
            intent: "Return input unchanged with contract ensuring result equals input",
            assembly_template: concat!(
                "FUNC 1 8\n",
                "PARAM I64\n",
                "POST 3\n",
                "REF 0\n",
                "REF 1\n",
                "EQ\n",
                "REF 0\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5], 5),
                i64_case(&[0], 0),
                i64_case(&[-10], -10),
                i64_case(&[42], 42),
            ],
            category: Category::RichContracts,
        },
        // ex173: zero_contract (POST: result == 0)
        ProgramSpec {
            id: "ex173_zero_contract",
            intent: "Return zero with contract ensuring result is zero",
            assembly_template: concat!(
                "FUNC 1 8\n",
                "PARAM I64\n",
                "POST 3\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "EQ\n",
                "CONST I64 0x0000 0x0000\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5], 0),
                i64_case(&[0], 0),
                i64_case(&[-10], 0),
                i64_case(&[42], 0),
            ],
            category: Category::RichContracts,
        },
        // ex174: sign_contract (multiple POSTs with IMPLIES)
        ProgramSpec {
            id: "ex174_sign_contract",
            intent: "Compute sign of integer with contracts ensuring correct sign mapping",
            assembly_template: concat!(
                "FUNC 1 44\n",
                "PARAM I64\n",
                "POST 7\n",
                "REF 1\n",
                "CONST I64 0x0000 0x0000\n",
                "GT\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0001\n",
                "EQ\n",
                "IMPLIES\n",
                "POST 7\n",
                "REF 1\n",
                "CONST I64 0x0000 0x0000\n",
                "LT\n",
                "REF 0\n",
                "CONST I64 0xffff 0xffff\n",
                "EQ\n",
                "IMPLIES\n",
                "POST 7\n",
                "REF 1\n",
                "CONST I64 0x0000 0x0000\n",
                "EQ\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "EQ\n",
                "IMPLIES\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GT\n",
                "MATCH 2\n",
                "CASE 0 9\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "LT\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "CONST I64 0x0000 0x0000\n",
                "CASE 1 1\n",
                "CONST I64 0xffff 0xffff\n",
                "EXHAUST\n",
                "CASE 1 1\n",
                "CONST I64 0x0000 0x0001\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5], 1),
                i64_case(&[-3], -1),
                i64_case(&[0], 0),
                i64_case(&[100], 1),
            ],
            category: Category::RichContracts,
        },
        // ex175: distance_contract (POST: result >= 0)
        ProgramSpec {
            id: "ex175_distance_contract",
            intent: "Compute absolute difference with contract ensuring non-negative result",
            assembly_template: concat!(
                "FUNC 2 23\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "POST 3\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GTE\n",
                "REF 1\n",
                "REF 0\n",
                "SUB\n",
                "CONST I64 0x0000 0x0000\n",
                "LT\n",
                "MATCH 2\n",
                "CASE 0 3\n",
                "REF 1\n",
                "REF 0\n",
                "SUB\n",
                "CASE 1 3\n",
                "REF 0\n",
                "REF 1\n",
                "SUB\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CONST I64 0x0000 0x0003\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5, 3], 2),
                i64_case(&[3, 5], 2),
                i64_case(&[0, 0], 0),
                i64_case(&[10, 3], 7),
            ],
            category: Category::RichContracts,
        },
        // ex176: average_contract (PRE: a>=0 AND b>=0, POST: result >= 0)
        ProgramSpec {
            id: "ex176_average_contract",
            intent: "Compute average of two non-negative integers with contracts",
            assembly_template: concat!(
                "FUNC 2 21\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "PRE 3\n",
                "REF 1\n",
                "CONST I64 0x0000 0x0000\n",
                "GTE\n",
                "PRE 3\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GTE\n",
                "POST 3\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GTE\n",
                "REF 1\n",
                "REF 0\n",
                "ADD\n",
                "CONST I64 0x0000 0x0002\n",
                "DIV\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x000a\n",
                "CONST I64 0x0000 0x0006\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[10, 6], 8),
                i64_case(&[0, 8], 4),
                i64_case(&[3, 3], 3),
                i64_case(&[5, 7], 6),
            ],
            category: Category::RichContracts,
        },
        // ex177: pre_positive (PRE: x>0)
        ProgramSpec {
            id: "ex177_pre_positive",
            intent: "Square a positive integer with precondition requiring positive input",
            assembly_template: concat!(
                "FUNC 1 10\n",
                "PARAM I64\n",
                "PRE 3\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GT\n",
                "REF 0\n",
                "REF 0\n",
                "MUL\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5], 25),
                i64_case(&[1], 1),
                i64_case(&[3], 9),
                i64_case(&[10], 100),
            ],
            category: Category::RichContracts,
        },
        // ex178: pre_nonzero (PRE: x!=0, body: 100/x)
        ProgramSpec {
            id: "ex178_pre_nonzero",
            intent: "Divide 100 by x with precondition requiring non-zero input",
            assembly_template: concat!(
                "FUNC 1 10\n",
                "PARAM I64\n",
                "PRE 3\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "NEQ\n",
                "CONST I64 0x0000 0x0064\n",
                "REF 0\n",
                "DIV\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x000a\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[10], 10),
                i64_case(&[5], 20),
                i64_case(&[1], 100),
                i64_case(&[2], 50),
            ],
            category: Category::RichContracts,
        },
        // ex179: pre_range (PRE: lo<=x<=hi)
        ProgramSpec {
            id: "ex179_pre_range",
            intent: "Square x with precondition requiring x to be within [lo, hi] range",
            assembly_template: concat!(
                "FUNC 3 16\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "PRE 7\n",
                "REF 1\n",
                "REF 2\n",
                "LTE\n",
                "REF 2\n",
                "REF 0\n",
                "LTE\n",
                "AND\n",
                "REF 2\n",
                "REF 2\n",
                "MUL\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CONST I64 0x0000 0x0000\n",
                "CONST I64 0x0000 0x000a\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5, 0, 10], 25),
                i64_case(&[0, 0, 10], 0),
                i64_case(&[3, 1, 5], 9),
                i64_case(&[10, 0, 100], 100),
            ],
            category: Category::RichContracts,
        },
        // ex180: multi_pre (PRE: a>0 AND PRE: b>0)
        ProgramSpec {
            id: "ex180_multi_pre",
            intent: "Multiply two positive integers with multiple preconditions",
            assembly_template: concat!(
                "FUNC 2 15\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "PRE 3\n",
                "REF 1\n",
                "CONST I64 0x0000 0x0000\n",
                "GT\n",
                "PRE 3\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GT\n",
                "REF 1\n",
                "REF 0\n",
                "MUL\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0003\n",
                "CONST I64 0x0000 0x0004\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[3, 4], 12),
                i64_case(&[1, 1], 1),
                i64_case(&[5, 2], 10),
                i64_case(&[7, 3], 21),
            ],
            category: Category::RichContracts,
        },
        // ex181: implies_contract (POST with IMPLIES: x >= 0 â†’ result >= 0)
        ProgramSpec {
            id: "ex181_implies_contract",
            intent: "Compute x times 2 with implication contract: if x is non-negative then result is non-negative",
            assembly_template: concat!(
                "FUNC 1 14\n",
                "PARAM I64\n",
                "POST 7\n",
                "REF 1\n",
                "CONST I64 0x0000 0x0000\n",
                "GTE\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GTE\n",
                "IMPLIES\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0002\n",
                "MUL\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5], 10),
                i64_case(&[0], 0),
                i64_case(&[-3], -6),
                i64_case(&[7], 14),
            ],
            category: Category::RichContracts,
        },
        // ex182: negate_contract (POST: result == -x)
        ProgramSpec {
            id: "ex182_negate_contract",
            intent: "Negate an integer with contract ensuring result is negative of input",
            assembly_template: concat!(
                "FUNC 1 10\n",
                "PARAM I64\n",
                "POST 4\n",
                "REF 0\n",
                "REF 1\n",
                "NEG\n",
                "EQ\n",
                "REF 0\n",
                "NEG\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5], -5),
                i64_case(&[-3], 3),
                i64_case(&[0], 0),
                i64_case(&[1], -1),
            ],
            category: Category::RichContracts,
        },
        // ex183: product_contract (POST: result == a * b)
        ProgramSpec {
            id: "ex183_product_contract",
            intent: "Multiply two integers with contract ensuring result equals their product",
            assembly_template: concat!(
                "FUNC 2 13\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "POST 5\n",
                "REF 0\n",
                "REF 2\n",
                "REF 1\n",
                "MUL\n",
                "EQ\n",
                "REF 1\n",
                "REF 0\n",
                "MUL\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0003\n",
                "CONST I64 0x0000 0x0004\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[3, 4], 12),
                i64_case(&[0, 5], 0),
                i64_case(&[1, 1], 1),
                i64_case(&[2, 5], 10),
            ],
            category: Category::RichContracts,
        },
        // ex184: difference_contract (POST: result == a - b)
        ProgramSpec {
            id: "ex184_difference_contract",
            intent: "Subtract b from a with contract ensuring result equals their difference",
            assembly_template: concat!(
                "FUNC 2 13\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "POST 5\n",
                "REF 0\n",
                "REF 2\n",
                "REF 1\n",
                "SUB\n",
                "EQ\n",
                "REF 1\n",
                "REF 0\n",
                "SUB\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CONST I64 0x0000 0x0003\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5, 3], 2),
                i64_case(&[3, 5], -2),
                i64_case(&[0, 0], 0),
                i64_case(&[10, 10], 0),
            ],
            category: Category::RichContracts,
        },
    ]
}
