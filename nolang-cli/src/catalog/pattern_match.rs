//! Pattern matching programs (15): ex115-ex129.

use super::{i64_case, Category, ProgramSpec, WitnessCase, WitnessValue};

pub fn programs() -> Vec<ProgramSpec> {
    vec![
        // ex115: bool_to_int — Standalone. Convert Bool to I64.
        ProgramSpec {
            id: "ex115_bool_to_int",
            intent: "Convert a boolean to an integer (true -> 1, false -> 0)",
            assembly_template: concat!(
                "CONST BOOL 0x0001 0x0000\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "CONST I64 0x0000 0x0000\n",
                "CASE 1 1\n",
                "CONST I64 0x0000 0x0001\n",
                "EXHAUST\n",
                "HALT\n",
            ),
            witness_cases: vec![],
            category: Category::PatternMatch,
        },
        // ex116: if_positive — Function (I64→I64). If x > 0, return x, else return 0.
        ProgramSpec {
            id: "ex116_if_positive",
            intent: "Return the input if positive, otherwise return zero",
            assembly_template: concat!(
                "FUNC 1 12\n",
                "PARAM I64\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GT\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "CONST I64 0x0000 0x0000\n",
                "CASE 1 1\n",
                "REF 0\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5], 5),
                i64_case(&[0], 0),
                i64_case(&[-3], 0),
                i64_case(&[100], 100),
            ],
            category: Category::PatternMatch,
        },
        // ex117: if_negative — Function (I64→I64). If x < 0, return x, else return 0.
        ProgramSpec {
            id: "ex117_if_negative",
            intent: "Return the input if negative, otherwise return zero",
            assembly_template: concat!(
                "FUNC 1 12\n",
                "PARAM I64\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "LT\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "CONST I64 0x0000 0x0000\n",
                "CASE 1 1\n",
                "REF 0\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0xffff 0xfffb\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[-5], -5),
                i64_case(&[0], 0),
                i64_case(&[3], 0),
                i64_case(&[-100], -100),
            ],
            category: Category::PatternMatch,
        },
        // ex118: three_way_sign — Function (I64→I64). If x>0 return 1, if x<0 return -1, else 0.
        ProgramSpec {
            id: "ex118_three_way_sign",
            intent: "Return 1 if positive, -1 if negative, 0 if zero",
            assembly_template: concat!(
                "FUNC 1 20\n",
                "PARAM I64\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GT\n",
                "MATCH 2\n",
                "CASE 0 9\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "LT\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "CONST I64 0x0000 0x0000\n",
                "CASE 1 1\n",
                "CONST I64 0xffff 0xffff\n",
                "EXHAUST\n",
                "CASE 1 1\n",
                "CONST I64 0x0000 0x0001\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0007\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[7], 1),
                i64_case(&[-7], -1),
                i64_case(&[0], 0),
                i64_case(&[1], 1),
            ],
            category: Category::PatternMatch,
        },
        // ex119: abs — Function (I64→I64). If x<0 return -x, else x.
        ProgramSpec {
            id: "ex119_abs",
            intent: "Compute the absolute value of an integer",
            assembly_template: concat!(
                "FUNC 1 13\n",
                "PARAM I64\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "LT\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "REF 0\n",
                "CASE 1 2\n",
                "REF 0\n",
                "NEG\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0xffff 0xfff3\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[-13], 13),
                i64_case(&[13], 13),
                i64_case(&[0], 0),
                i64_case(&[-1], 1),
            ],
            category: Category::PatternMatch,
        },
        // ex120: clamp_to_zero — Function (I64→I64). If x<0 return 0, else x.
        ProgramSpec {
            id: "ex120_clamp_to_zero",
            intent: "Clamp negative values to zero",
            assembly_template: concat!(
                "FUNC 1 12\n",
                "PARAM I64\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "LT\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "REF 0\n",
                "CASE 1 1\n",
                "CONST I64 0x0000 0x0000\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0xffff 0xfffb\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[-5], 0),
                i64_case(&[0], 0),
                i64_case(&[5], 5),
                i64_case(&[-100], 0),
            ],
            category: Category::PatternMatch,
        },
        // ex121: max — Function (I64,I64→I64). Return max(a,b).
        ProgramSpec {
            id: "ex121_max",
            intent: "Return the maximum of two integers",
            assembly_template: concat!(
                "FUNC 2 13\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "REF 1\n",
                "REF 0\n",
                "GTE\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "REF 0\n",
                "CASE 1 1\n",
                "REF 1\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CONST I64 0x0000 0x0003\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5, 3], 5),
                i64_case(&[3, 5], 5),
                i64_case(&[7, 7], 7),
                i64_case(&[-2, 4], 4),
            ],
            category: Category::PatternMatch,
        },
        // ex122: min — Function (I64,I64→I64). Return min(a,b).
        ProgramSpec {
            id: "ex122_min",
            intent: "Return the minimum of two integers",
            assembly_template: concat!(
                "FUNC 2 13\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "REF 1\n",
                "REF 0\n",
                "LTE\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "REF 0\n",
                "CASE 1 1\n",
                "REF 1\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CONST I64 0x0000 0x0003\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5, 3], 3),
                i64_case(&[3, 5], 3),
                i64_case(&[7, 7], 7),
                i64_case(&[-2, 4], -2),
            ],
            category: Category::PatternMatch,
        },
        // ex123: match_bool_and — Standalone. AND of two bools via nested match.
        ProgramSpec {
            id: "ex123_match_bool_and",
            intent: "Compute logical AND of two booleans (true AND true = true)",
            assembly_template: concat!(
                "CONST BOOL 0x0001 0x0000\n",
                "CONST BOOL 0x0001 0x0000\n",
                "AND\n",
                "HALT\n",
            ),
            witness_cases: vec![],
            category: Category::PatternMatch,
        },
        // ex124: match_variant_sum — Standalone. Create Some(5), unwrap and add 10.
        ProgramSpec {
            id: "ex124_match_variant_sum",
            intent: "Unwrap Some(5), add 10, and return 15",
            assembly_template: concat!(
                "CONST I64 0x0000 0x0005\n",
                "VARIANT_NEW VARIANT 2 0\n",
                "MATCH 2\n",
                "CASE 0 4\n",
                "BIND\n",
                "REF 0\n",
                "CONST I64 0x0000 0x000a\n",
                "ADD\n",
                "CASE 1 1\n",
                "CONST I64 0x0000 0x0000\n",
                "EXHAUST\n",
                "HALT\n",
            ),
            witness_cases: vec![],
            category: Category::PatternMatch,
        },
        // ex125: match_three_variant — Standalone. 3-tag variant, match all 3.
        ProgramSpec {
            id: "ex125_match_three_variant",
            intent: "Create a 3-tag variant and match all three cases",
            assembly_template: concat!(
                "CONST I64 0x0000 0x002a\n",
                "VARIANT_NEW VARIANT 3 2\n",
                "MATCH 3\n",
                "CASE 0 1\n",
                "CONST I64 0x0000 0x000a\n",
                "CASE 1 1\n",
                "CONST I64 0x0000 0x0014\n",
                "CASE 2 2\n",
                "BIND\n",
                "CONST I64 0x0000 0x001e\n",
                "EXHAUST\n",
                "HALT\n",
            ),
            witness_cases: vec![],
            category: Category::PatternMatch,
        },
        // ex126: nested_bool_match — Standalone. Match on bool, then match on another bool inside.
        ProgramSpec {
            id: "ex126_nested_bool_match",
            intent: "Use nested boolean pattern matching to compute a result",
            assembly_template: concat!(
                "CONST BOOL 0x0001 0x0000\n",
                "MATCH 2\n",
                "CASE 0 7\n",
                "CONST BOOL 0x0000 0x0000\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "CONST I64 0x0000 0x0001\n",
                "CASE 1 1\n",
                "CONST I64 0x0000 0x0002\n",
                "EXHAUST\n",
                "CASE 1 7\n",
                "CONST BOOL 0x0001 0x0000\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "CONST I64 0x0000 0x0003\n",
                "CASE 1 1\n",
                "CONST I64 0x0000 0x0004\n",
                "EXHAUST\n",
                "EXHAUST\n",
                "HALT\n",
            ),
            witness_cases: vec![],
            category: Category::PatternMatch,
        },
        // ex127: conditional_negate — Function (I64,Bool→I64). If Bool is true, negate the I64.
        ProgramSpec {
            id: "ex127_conditional_negate",
            intent: "Negate the input integer if the boolean flag is true",
            assembly_template: concat!(
                "FUNC 2 12\n",
                "PARAM I64\n",
                "PARAM BOOL\n",
                "REF 0\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "REF 1\n",
                "CASE 1 2\n",
                "REF 1\n",
                "NEG\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CONST BOOL 0x0001 0x0000\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                WitnessCase {
                    inputs: vec![WitnessValue::I64(5), WitnessValue::Bool(false)],
                    expected: WitnessValue::I64(5),
                },
                WitnessCase {
                    inputs: vec![WitnessValue::I64(5), WitnessValue::Bool(true)],
                    expected: WitnessValue::I64(-5),
                },
                WitnessCase {
                    inputs: vec![WitnessValue::I64(-7), WitnessValue::Bool(false)],
                    expected: WitnessValue::I64(-7),
                },
                WitnessCase {
                    inputs: vec![WitnessValue::I64(-7), WitnessValue::Bool(true)],
                    expected: WitnessValue::I64(7),
                },
            ],
            category: Category::PatternMatch,
        },
        // ex128: select_by_sign — Function (I64→I64). Return 1 if positive, -1 if negative, 0 if zero.
        ProgramSpec {
            id: "ex128_select_by_sign",
            intent: "Return the sign of an integer as -1, 0, or 1",
            assembly_template: concat!(
                "FUNC 1 20\n",
                "PARAM I64\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "EQ\n",
                "MATCH 2\n",
                "CASE 0 9\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GT\n",
                "MATCH 2\n",
                "CASE 0 1\n",
                "CONST I64 0xffff 0xffff\n",
                "CASE 1 1\n",
                "CONST I64 0x0000 0x0001\n",
                "EXHAUST\n",
                "CASE 1 1\n",
                "CONST I64 0x0000 0x0000\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0xffff 0xfff9\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[-7], -1),
                i64_case(&[0], 0),
                i64_case(&[7], 1),
                i64_case(&[1], 1),
            ],
            category: Category::PatternMatch,
        },
        // ex129: safe_div — Function (I64,I64→I64). If b==0 return 0, else a/b.
        ProgramSpec {
            id: "ex129_safe_div",
            intent: "Safely divide two integers, returning zero on division by zero",
            assembly_template: concat!(
                "FUNC 2 15\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "EQ\n",
                "MATCH 2\n",
                "CASE 0 3\n",
                "REF 1\n",
                "REF 0\n",
                "DIV\n",
                "CASE 1 1\n",
                "CONST I64 0x0000 0x0000\n",
                "EXHAUST\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x000a\n",
                "CONST I64 0x0000 0x0002\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[10, 2], 5),
                i64_case(&[10, 0], 0),
                i64_case(&[7, 3], 2),
                i64_case(&[0, 5], 0),
            ],
            category: Category::PatternMatch,
        },
    ]
}
