//! Bitwise operations programs (15): ex085-ex099.

use super::{i64_case, i64_to_bool_case, Category, ProgramSpec};

pub fn programs() -> Vec<ProgramSpec> {
    vec![
        // ex085: bitwise_and (a AND b)
        ProgramSpec {
            id: "ex085_bitwise_and",
            intent: "Bitwise AND of two integers",
            assembly_template: concat!(
                "FUNC 2 7\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "REF 1\n",
                "REF 0\n",
                "AND\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x00ff\n",
                "CONST I64 0x0000 0x000f\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[0xFF, 0x0F], 0x0F),
                i64_case(&[0xAAAA, 0x5555], 0),
                i64_case(&[0xFFFF, 0xFFFF], 0xFFFF),
                i64_case(&[0, 0xFFFF], 0),
            ],
            category: Category::BitwiseOps,
        },
        // ex086: bitwise_or (a OR b)
        ProgramSpec {
            id: "ex086_bitwise_or",
            intent: "Bitwise OR of two integers",
            assembly_template: concat!(
                "FUNC 2 7\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "REF 1\n",
                "REF 0\n",
                "OR\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x00f0\n",
                "CONST I64 0x0000 0x000f\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[0xF0, 0x0F], 0xFF),
                i64_case(&[0xAAAA, 0x5555], 0xFFFF),
                i64_case(&[0, 0], 0),
                i64_case(&[0xFF, 0], 0xFF),
            ],
            category: Category::BitwiseOps,
        },
        // ex087: bitwise_xor (a XOR b)
        ProgramSpec {
            id: "ex087_bitwise_xor",
            intent: "Bitwise XOR of two integers",
            assembly_template: concat!(
                "FUNC 2 7\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "REF 1\n",
                "REF 0\n",
                "XOR\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x00ff\n",
                "CONST I64 0x0000 0x000f\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[0xFF, 0x0F], 0xF0),
                i64_case(&[0xAAAA, 0x5555], 0xFFFF),
                i64_case(&[0xFF, 0xFF], 0),
                i64_case(&[0, 0xFF], 0xFF),
            ],
            category: Category::BitwiseOps,
        },
        // ex088: bitwise_not (NOT a)
        ProgramSpec {
            id: "ex088_bitwise_not",
            intent: "Bitwise NOT of an integer",
            assembly_template: concat!(
                "FUNC 1 5\n",
                "PARAM I64\n",
                "REF 0\n",
                "NOT\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x000f\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[0x0F], -16),
                i64_case(&[0], -1),
                i64_case(&[-1], 0),
                i64_case(&[0xFF], -256),
            ],
            category: Category::BitwiseOps,
        },
        // ex089: shift_left (val SHL n)
        ProgramSpec {
            id: "ex089_shift_left",
            intent: "Shift an integer left by a specified number of bits",
            assembly_template: concat!(
                "FUNC 2 7\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "REF 1\n",
                "REF 0\n",
                "SHL\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0005\n",
                "CONST I64 0x0000 0x0002\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[5, 2], 20),
                i64_case(&[1, 3], 8),
                i64_case(&[0xFF, 4], 0xFF0),
                i64_case(&[7, 0], 7),
            ],
            category: Category::BitwiseOps,
        },
        // ex090: shift_right (val SHR n)
        ProgramSpec {
            id: "ex090_shift_right",
            intent: "Shift an integer right by a specified number of bits",
            assembly_template: concat!(
                "FUNC 2 7\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "REF 1\n",
                "REF 0\n",
                "SHR\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0014\n",
                "CONST I64 0x0000 0x0002\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[20, 2], 5),
                i64_case(&[8, 3], 1),
                i64_case(&[0xFF0, 4], 0xFF),
                i64_case(&[7, 0], 7),
            ],
            category: Category::BitwiseOps,
        },
        // ex091: set_bit (val OR (1 SHL pos))
        ProgramSpec {
            id: "ex091_set_bit",
            intent: "Set a specific bit in an integer",
            assembly_template: concat!(
                "FUNC 2 9\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "REF 1\n",
                "CONST I64 0x0000 0x0001\n",
                "REF 0\n",
                "SHL\n",
                "OR\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0000\n",
                "CONST I64 0x0000 0x0003\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[0, 3], 8),
                i64_case(&[8, 3], 8),
                i64_case(&[0, 0], 1),
                i64_case(&[5, 1], 7),
            ],
            category: Category::BitwiseOps,
        },
        // ex092: clear_bit (val AND NOT (1 SHL pos))
        ProgramSpec {
            id: "ex092_clear_bit",
            intent: "Clear a specific bit in an integer",
            assembly_template: concat!(
                "FUNC 2 10\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "REF 1\n",
                "CONST I64 0x0000 0x0001\n",
                "REF 0\n",
                "SHL\n",
                "NOT\n",
                "AND\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x000f\n",
                "CONST I64 0x0000 0x0003\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[0x0F, 3], 7),
                i64_case(&[7, 3], 7),
                i64_case(&[8, 3], 0),
                i64_case(&[0xFF, 0], 0xFE),
            ],
            category: Category::BitwiseOps,
        },
        // ex093: test_bit ((val SHR pos) AND 1 != 0)
        ProgramSpec {
            id: "ex093_test_bit",
            intent: "Test if a specific bit is set in an integer",
            assembly_template: concat!(
                "FUNC 2 11\n",
                "PARAM I64\n",
                "PARAM I64\n",
                "REF 1\n",
                "REF 0\n",
                "SHR\n",
                "CONST I64 0x0000 0x0001\n",
                "AND\n",
                "CONST I64 0x0000 0x0000\n",
                "NEQ\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0008\n",
                "CONST I64 0x0000 0x0003\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_to_bool_case(&[8, 3], true),
                i64_to_bool_case(&[7, 3], false),
                i64_to_bool_case(&[0xFF, 0], true),
                i64_to_bool_case(&[0xFE, 0], false),
            ],
            category: Category::BitwiseOps,
        },
        // ex094: is_power_of_two (x > 0 AND (x AND (x-1)) == 0)
        ProgramSpec {
            id: "ex094_is_power_of_two",
            intent: "Check if an integer is a power of two",
            assembly_template: concat!(
                "FUNC 1 14\n",
                "PARAM I64\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0000\n",
                "GT\n",
                "REF 0\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0001\n",
                "SUB\n",
                "AND\n",
                "CONST I64 0x0000 0x0000\n",
                "EQ\n",
                "AND\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0008\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_to_bool_case(&[8], true),
                i64_to_bool_case(&[7], false),
                i64_to_bool_case(&[1], true),
                i64_to_bool_case(&[0], false),
            ],
            category: Category::BitwiseOps,
        },
        // ex095: low_nibble (x AND 0x000f)
        ProgramSpec {
            id: "ex095_low_nibble",
            intent: "Extract the lowest 4 bits of an integer",
            assembly_template: concat!(
                "FUNC 1 6\n",
                "PARAM I64\n",
                "REF 0\n",
                "CONST I64 0x0000 0x000f\n",
                "AND\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x00ff\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[0xFF], 0x0F),
                i64_case(&[0x1234], 0x04),
                i64_case(&[0], 0),
                i64_case(&[0x0F], 0x0F),
            ],
            category: Category::BitwiseOps,
        },
        // ex096: high_byte ((x SHR 8) AND 0x00ff)
        ProgramSpec {
            id: "ex096_high_byte",
            intent: "Extract the second byte of an integer",
            assembly_template: concat!(
                "FUNC 1 8\n",
                "PARAM I64\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0008\n",
                "SHR\n",
                "CONST I64 0x0000 0x00ff\n",
                "AND\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x1234\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[0x1234], 0x12),
                i64_case(&[0xFF00], 0xFF),
                i64_case(&[0x00FF], 0),
                i64_case(&[0xABCD], 0xAB),
            ],
            category: Category::BitwiseOps,
        },
        // ex097: zero_lowest_bit (x AND (x-1))
        ProgramSpec {
            id: "ex097_zero_lowest_bit",
            intent: "Clear the lowest set bit in an integer",
            assembly_template: concat!(
                "FUNC 1 8\n",
                "PARAM I64\n",
                "REF 0\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0001\n",
                "SUB\n",
                "AND\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0008\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[8], 0),
                i64_case(&[7], 6),
                i64_case(&[12], 8),
                i64_case(&[0], 0),
            ],
            category: Category::BitwiseOps,
        },
        // ex098: mask_n_bits ((1 SHL n) - 1)
        ProgramSpec {
            id: "ex098_mask_n_bits",
            intent: "Create a bitmask with n bits set",
            assembly_template: concat!(
                "FUNC 1 8\n",
                "PARAM I64\n",
                "CONST I64 0x0000 0x0001\n",
                "REF 0\n",
                "SHL\n",
                "CONST I64 0x0000 0x0001\n",
                "SUB\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0004\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[4], 0x0F),
                i64_case(&[8], 0xFF),
                i64_case(&[0], 0),
                i64_case(&[1], 1),
            ],
            category: Category::BitwiseOps,
        },
        // ex099: count_set_lsb (x AND 1)
        ProgramSpec {
            id: "ex099_count_set_lsb",
            intent: "Check if the least significant bit is set",
            assembly_template: concat!(
                "FUNC 1 6\n",
                "PARAM I64\n",
                "REF 0\n",
                "CONST I64 0x0000 0x0001\n",
                "AND\n",
                "RET\n",
                "HASH 0x0000 0x0000 0x0000\n",
                "ENDFUNC\n",
                "CONST I64 0x0000 0x0007\n",
                "CALL 0\n",
                "HALT\n",
            ),
            witness_cases: vec![
                i64_case(&[7], 1),
                i64_case(&[8], 0),
                i64_case(&[0], 0),
                i64_case(&[1], 1),
            ],
            category: Category::BitwiseOps,
        },
    ]
}
